#!/bin/bash
# usage: sql_enter_alignments 061212_A_MM1 accepted_hits.sam
#        sql_enter_alignments 061212_A_MM1 accepted_hits.bam
#
#  No that won't work because the sam file still has the header on it.
#
# Note that this script will NOT work if the <file> is not a text file.
# e.g. you cannot use this as sql_enter_alignments 061212_A_MM1 /dev/stdin
# That won't work!   Why?   Because we use the SQL command "LOAD DATA LOCAL INFILE"

function usage {
    echo "usage: $0 <dataseet> <alignment_file>"
    echo "e.g. $0 073012_A_MM1 accepted_hits.bam"
    echo "   . $0 073012_A_MM1 accepted_hits.sam"
}


while getopts ":h" opt; do
  case $opt in
    a)
      usage;
      exit 1;
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      ;;
  esac
done

if [[ $# < 2 ]]; then
    usage;
    exit 1;
fi

expr=$1;
file=$2;
file=$(readlink -f ${file})

tmpfile=$(mktemp)
trap "rm -f $tmpfile" EXIT

alignment_cmd=""

case "$(file ${file})" in
    *ASCII* )
	# do nothing special
         ;;
    *"gzip compressed"* )
        #samtools view ${file} >$tmpfile
	echo "samtools view -H ${file} | grep @PG | sed 's/^.*CL://'"
	alignment_cmd="$(samtools view -H ${file} | grep @PG | sed 's/^.*CL://')"	
	samtools view ${file} >${tmpfile}
	file="${tmpfile}"
	;;
    *)
	echo "Unrecognized file type - ${file}"
	exit 1;;
esac

## The alignments being inserted have a long string read_id (e.g. 121001_IPAR1_00151_FC_64LB0AAXX:6:1:11374:1006:1#0/1)
## that is NOT unique.   In other words, a single read may be aligned to multiple places in the genome.
## upon inserting into the database we want to A) use a smaller read id, because the string is too long, and B) guarantee that the 
## ids are unique for a goven experiment.

## The technique used is to,
## A) read the alignments into a table that does not require the name field to be unique.   These will be duplicate read names.
## B) SELECT DISTINCT names from the first table into another table with unique names and an autoincrement id field.
## C) make the final table by joining these two tables on name field.


## mysql -B morris <<END-SQL
(tee /dev/stderr | mysql -B morris) <<END-SQL

use morris;

## Lookup the id of the dataset we are updating.
select "looking up dataset id for ${expr}." as 'Msg';
SET @id = (SELECT id FROM datasets_tbl WHERE name LIKE '${expr}');
select @id as \`datasets ${expr}\`;

select "entered sql_enter_alignments." as 'Msg';
CREATE TEMPORARY TABLE tmp_alignments_tbl (
  \`name\` varchar(50) NOT NULL,
  \`dataset_id\` int(4) NOT NULL,
  \`chrom\` varchar(50) NOT NULL,
  \`strand\` char(1) NOT NULL,
  \`position\` int(4) unsigned NOT NULL,
  \`length\` int(4) unsigned NOT NULL,
  \`CIGAR\` varchar(50) NOT NULL,
  \`XF\` varchar(150) NOT NULL,
key(name)
);


## insert alignments into a temporary tables allowing for duplicate
## read names
##
select "calling load local infile." as 'Msg';
LOAD DATA LOCAL INFILE '${file}'
    INTO TABLE tmp_alignments_tbl  
    (name, @flags, chrom, position, @dummy, CIGAR, @dummy, @dummy, @dummy, @sequence,@quality,@XA,@MD,@NM,XF)
    SET dataset_id = @id, 
        strand = (CASE (@flags & 16) when 16 then '-' else '+' END ),
        length = CHAR_LENGTH(@sequence);


## Copy the names column into a temporary table that does not allow
## duplicates and which assigns a uniqe id to each name

CREATE TEMPORARY TABLE tmp_names_tbl (
  \`id\` int(4) NOT NULL AUTO_INCREMENT,
  \`name\` varchar(50) UNIQUE NOT NULL,
  PRIMARY KEY (id),
  KEY(name)
);

select "copying name column into tmp_names_tbl." as 'Msg';
INSERT INTO morris.tmp_names_tbl (name) 
SELECT DISTINCT name FROM morris.tmp_alignments_tbl;

## count the number of unique names just as a sanity check.
## select COUNT(*) from morris.tmp_names_tbl;

## Delete the old alignments for this dataset.
##
select "deleting old alignments." as 'Msg';
delete from morris.new_alignments_tbl where dataset_id=@id;

## Copy all columns except name from the temporary alignment table,
## replacing the name with the unique id from the temporary names
## table.

select "inserting new alignments." as 'Msg';
INSERT INTO morris.new_alignments_tbl 
    (dataset_id, read_id, chrom, strand, position, length, CIGAR, feature)
    SELECT 
    a.dataset_id, n.id, a.chrom, a.strand, a.position, a.length, a.CIGAR, SUBSTR(a.XF FROM 6)
    FROM tmp_alignments_tbl a 
    INNER JOIN tmp_names_tbl n ON a.name=n.name;

END-SQL


 
if [ ! -z "$alignment_cmd" ]
then
##mysql -B morris <<END-SQL
(tee /dev/stderr | mysql -B morris) <<END-SQL

## update the record of the command used to generate these alignments.
##

use morris;
UPDATE \`morris\`.\`datasets_tbl\` SET \`alignment_cmd\`='${alignment_cmd}' WHERE name LIKE '${expr}';

END-SQL

fi

# end of script